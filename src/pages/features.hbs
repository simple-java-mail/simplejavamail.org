{{#> layouts/base head-sub-title="Features" page-title="Simple Java Mail Features" }}

	{{#*inline "html-head-block"}}
<meta name="Description" content="Simple Java Mail includes CLI, auth. socks proxy, OAUTH2, custom headers and properties, address validation, DKIM, S/MIME, config files, Spring support and conversions">
	{{/inline}}

	{{#*inline "header-block"}}
        {{> includes/header topic="features" }}
    {{/inline}}

    {{#*inline "body-block"}}
  <section class="introduction">
    <p class="wide" style="font-size:smaller">
      (also check <a href="configuration.html#navigation">configuration</a> and <a href="security.html#navigation">security</a>
		if you're missing a feature)
    </p>

    <p class="wide">
      Creating and sending emails is very simple with Simple Java Mail; you don't need to know about the mailing RFC, MimeMessage or any other low
      level <code class="inline language-text">javax.mail</code> API. No anonymous inner classes needed and no <a
      href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/mail.html">large frameworks</a> needed nor XML.
    </p>

    <h3>Entry classes</h3>
    <p class="wide">
      The primary entry classes are
      <strong><a href="https://javadoc.io/page/org.simplejavamail/simple-java-mail/latest/org/simplejavamail/email/EmailBuilder.html" target="_blank">
        EmailBuilder</a></strong> and
      <strong><a href="https://javadoc.io/page/org.simplejavamail/simple-java-mail/latest/org/simplejavamail/mailer/MailerBuilder.html" target="_blank">
        MailerBuilder</a></strong>. Other entry classes are
      <strong><a href="https://javadoc.io/page/org.simplejavamail/simple-java-mail/latest/org/simplejavamail/converter/EmailConverter.html" target="_blank">
        EmailConverter</a></strong> and
      <strong><a href="https://javadoc.io/doc/com.sanctionco.jmail/jmail/latest/com.sanctionco.jmail/com/sanctionco/jmail/JMail.html" target="_blank">
        JMail</a></strong> (the latter as alternative to using the validation methods on the Mailer instance). Finally,
      <strong><a href="https://javadoc.io/page/org.simplejavamail/simple-java-mail/latest/org/simplejavamail/mailer/MailerHelper.html" target="_blank">
        MailerHelper</a></strong> exposes some utilities in case you don't actually need to connect to a server.
    </p>

    <h3>Default features</h3>
    <p class="wide">
      Simple Java Mail will do some basic validation checks so that your email is always populated with enough data.
      It also checks for CRLF injection attacks. It even verifies email addresses against
      <a href="https://tools.ietf.org/html/rfc2822" target="_blank">RFC-2822</a> and others using
      <a href="https://github.com/RohanNagar/jmail" target="_blank">JMail</a>.
      Simple Java Mail also takes care of all the
      <a href="https://javadoc.io/doc/com.sun.mail/jakarta.mail/2.0.1/jakarta.mail/com/sun/mail/smtp/package-summary.html" target="_blank">connection and security properties</a> for you.
    </p>

    <h3>Builders all the way down</h3>
    <p class="wide">
      With all the possible ways to configure Email and Mailer instances, the library had only one option left to streamline API, avoid the
      <a href="https://codethataint.com/blog/builder-pattern/" target="_blank">Telescoping Constructor</a> anti-pattern and keep things
      manageable: <a href="https://martinfowler.com/bliki/FluentInterface.html" target="_blank">fluent builders</a>.
    </p>
    <ol class="indent" style="margin-bottom: 1em">
      <li>With fluent builders, we can tightly control <strong>valid combinations</strong>, logical <strong>decision paths</strong> and easily <strong>provide
        alternative methods</strong>.
      </li>
      <li>At the same time we can concentrate all mutation logic in the builders and produce mostly <strong>immutable objects</strong>.</li>
      <li>Finally, we're able to <strong>centralize our documentation</strong> around the builders and refer to it from wherever this library is used.</li>
    </ol>

    <h3>How does Simple Java Mail compare to other mailing libraries?</h3>
    <p class="wide">
		Checkout the <strong><a href="feature-matrix.html#navigation">feature comparison matrix</a></strong> to see how Simple Java Mail fares against other
		libraries, like Apache Commons Email and Spring Mail.
    </p>

	<h3>Migrating from an older version?</h3>
	<p class="wide">
		Checkout the <a href="migration-notes.html#navigation">migration notes</a> to see exactly what changed.
	</p>
  </section>

  <section class="toc">
    <ul>
		<li><a href="#section-basic-usage">Basic usage</a></li>
		<li><a href="#section-builder-api" class="indent">About the fluent API with the Builder pattern</a></li>
		<li><a href="#section-reusable-mailer" class="indent">Configure once, reuse many times</a></li>
		<li><a href="#section-add-recipients" class="indent">Alternative API for almost everything</a></li>
		<li><a href="#authentication" class="indent">Authentication and OAUTH2 support</a></li>
		<li><a href="#section-sending-asynchronously" class="indent">Asynchronous parallel batch sending and clustering</a></li>
		<li><a href="#section-handling-async-result" class="indent">Handling asynchronous mailing result</a></li>
		<li><a href="#section-content-transfer-encoding">Changing the content encoding</a></li>
		<li><a href="#section-custom-session">Sending with your own Session instance</a></li>
		<li><a href="#section-custom-id">Setting a custom message ID on sent email</a></li>
		<li><a href="#section-custom-sentdate">Setting a custom sent date on sent email</a></li>
		<li><a href="#section-sent-id">Getting the generated email id after sending</a></li>
		<li><a href="#section-ssl-tls">Sending with SSL and TLS</a></li>
		<li><a href="#section-gmail" class="indent">SSL and TLS with Google mail</a></li>
		<li><a href="#section-attachments">Adding attachments</a></li>
		<li><a href="#section-embedding">Embedding images</a></li>
		<li><a href="#section-custom-headers">Setting custom headers</a></li>
		<li><a href="#section-custom-properties">Setting custom properties on the internal Session</a></li>
		<li><a href="#section-icalendar-vevent">Sending a Calendar event (iCalendar vEvent)</a></li>
		<li><a href="#section-session-access">Direct access to the internal Session</a></li>
		<li><a href="#section-return-receipt">Configure delivery / read receipt</a></li>
		<li><a href="#section-email-validation">Validating Email Addresses</a></li>
		<li><a href="#section-converting">Converting between email formats</a></li>
		<li><a href="#section-bouncing-emails">Setting custom recipient for bouncing emails</a></li>
		<li><a href="#section-reply-forward">Replying to and forwarding emails</a></li>
		<li><a href="#section-proxy">Send using a proxy</a></li>
		<li><a href="#section-connection-test">Testing a server connection</a></li>
		<li><a href="#section-serializing-emails">Serializing Email objects</a></li>
		<li><a href="#section-custom-mailer">Plug your own sending logic</a></li>
		<li><a href="#section-maximum-emailsize">Limit the maximum email size</a></li>
    </ul>
  </section>

  <section class="roadmap">
    <h2>Roadmap</h2>
    <p>Currently everything we can think of is included or on the issue tracker!</p>
    <p>Got a suggestion? Please post it in the <a
      href="https://github.com/bbottema/simple-java-mail/issues"><strong>issue tracker</strong></a>.</p>
  </section>

  <a href="#section-basic-usage" id="section-basic-usage" class="section-link h2">&sect;</a>
  <h2>Basic usage</h2>

  <section>
	  <div class="view">
		  <p>
			  Simply build an <code class="inline language-java">Email</code>, populate it with your data, build a <code class="inline language-java">Mailer</code> and send the Email
			  instance. The mailer can be <a href="#section-custom-session">created with your own <code class="inline language-java">Session</code> instance as well</a>.
		  </p>
		  <p>
			  A Mailer instance is reusable.
		  </p>
		  <p>
			  Muliple Mailer instances can form a <a href="configuration.html#section-clustering">powerful cluster</a>.
		  </p>
	  </div>

	  <div class="side">
<pre><code class="small">Email email = EmailBuilder.startingBlank()
    .from("Michel Baker", "m.baker@mbakery.com")
    .to("mom", "jean.baker@hotmail.com")
    .to("dad", "StevenOakly1963@hotmail.com")
    .withSubject("My Bakery is finally open!")
    .withPlainText("Mom, Dad. We did the opening ceremony of our bakery!!!")
	.withHTMLText("&lt;p&gt;Mom, Dad. We did the opening ceremony of &lt;strong&gt;our bakery&lt;/strong&gt;!!!&lt;/p&gt;")
    .buildEmail();

MailerBuilder
  .withSMTPServer("server", 25, "username", "password")
  .buildMailer()
  .sendMail(email);
</code></pre>
	  </div>
  </section>


  <a href="#section-builder-api" id="section-builder-api" class="section-link h3">&sect;</a>
  <h3>About the fluent API with the Builder pattern</h3>

  <section>
    <p class="wide">
      The entry classes for the builders are
      <a href="https://javadoc.io/page/org.simplejavamail/simple-java-mail/latest/org/simplejavamail/email/EmailBuilder.html" target="_blank">
        EmailBuilder</a> and
      <a href="https://javadoc.io/page/org.simplejavamail/simple-java-mail/latest/org/simplejavamail/mailer/MailerBuilder.html" target="_blank">
        MailerBuilder</a>.
    </p>
    <p class="wide">
      For <strong>EmailBuilder</strong>, the first method initializes the builder in different ways, leaving it with defaults
		(<code class="inline language-java">EmailBuilder.startingBlank()</code>), preconfiguring it
      (<code class="inline language-java">EmailBuilder.copying()</code>, <code class="inline language-java">EmailBuilder.replyingTo()</code>),
      or by setting values otherwise not possible (<code class="inline language-java">EmailBuilder.forwarding()</code>).
    </p>
    <p class="wide">
      For <strong>MailerBuilder</strong>, the first method determines if you get a full builder API or a reduced API because you provided
      your own custom Session instance.<br/>
      <strong>If you provide your own session, a lot of properties are presumed to be preconfigured</strong>, such as SMTP server details.
    </p>
  </section>

  <a href="#section-reusable-mailer" id="section-reusable-mailer" class="section-link h3">&sect;</a>
  <h3>Configure once, reuse many times</h3>

  <section>
    <div class="view">
      <p>
        You can preconfigure a <code class="inline language-java">Mailer</code> and use it many times. It is thread-safe.
      </p>
    </div>

    <div class="side">
<pre><code>Mailer inhouseMailer = MailerBuilder
    .withSMTPServer("server", 25, "username", "password")
    .buildMailer();

inhouseMailer.sendMail(email);
inhouseMailer.sendMail(anotherEmail);
</code></pre>
      Or as preconfigured Spring bean:
      <pre><code>@Bean
public Mailer inhouseMailer() {
    return MailerBuilder
        .withSMTPServer(...)
        .buildMailer();
}
</code></pre>
      Or the default one from the <a href="configuration.html#section-spring-support">Spring support module</a>:
      <pre><code>
@Import(SimpleJavaMailSpringSupport.class)

@Autowired Mailer mailer; // configured completely using default properties
</code></pre>
    </div>
  </section>


  <a href="#section-add-recipients" id="section-add-recipients" class="section-link h3">&sect;</a>
  <h3>Alternative API for almost everything</h3>

  <section>
    <div>
      <p class="wide">
        Simple Java Mail has alternative ways to do things for almost everything...
      </p>
      <p class="wide">
        For example, when building an email, you can add recipients using
        <a href="https://github.com/bbottema/simple-java-mail/blob/master/modules/core-module/src/main/java/org/simplejavamail/api/email/Recipient.java" target="_blank">Recipient</a>
        objects, <a href="">RFC822 compliant String addresses</a> (each can be comma delimited and include optional nested names),
        <a href="https://jakarta.ee/specifications/platform/8/apidocs/javax/mail/internet/internetaddress" target="_blank">InternetAddress</a>
        objects, collections of said addresses, default address names or fixed address names.
      </p>
    </div>

    <div>
      <pre><code>// You can add your own Recipient instances for example
currentEmailBuilder.withRecipients(yourRecipient1, yourRecipient2...);</code></pre>

      <pre><code>// or add comma / semicolon separated addresses (without names)
String list = "twister@sweets.com,blue.tongue@sweets.com;honey@sweets.com";
currentEmailBuilder.bcc(list);</code></pre>
      <pre><code>// or:
currentEmailBuilder.bccWithDefaultName("maintenance group", list);
currentEmailBuilder.bccWithFixedName("maintenance group", list); // same as .bcc()</code></pre>

      <pre><code>// what about a group with one deviating name?
String list = "bob@sweets.com, gene@sweets.com; Security Group &lt;security@sweets.com&gt;";
currentEmailBuilder.toWithDefaultName("stakeholders", list);
// bob and gene are named "stakeholders", "Security Group" get its own name</code></pre>
      <p>Through properties:</p>
      <pre><code class="language-properties">simplejavamail.defaults.bcc.name=
simplejavamail.defaults.bcc.address=twister@sweets.com,blue.tongue@sweets.com;honey@sweets.com
</code></pre>
    </div>

    <div>
      <div class="view">
        <p>To give you an idea of how flexible the API is for <strong>just adding recipients:</strong></p>
      </div>
      <div class="side">
      <pre><code class="small">// TO
.to(Recipient... recipients)
.to(Collection&lt;Recipient&gt; recipients)
.to(String name, String address)
.to(String oneOrMoreAddresses)
.to(String name, String... oneOrMoreAddressesEach)
.to(String name, Collection&lt;String&gt; oneOrMoreAddressesEach)
.toMultiple(String... oneOrMoreAddressesEach)
.toMultiple(Collection&lt;String&gt; oneOrMoreAddressesEach)
.toWithFixedName(String name, String... oneOrMoreAddressesEach)
.toWithDefaultName(String name, String... oneOrMoreAddressesEach)
.toWithFixedName(String name, Collection&lt;String&gt; oneOrMoreAddressesEach)
.toWithDefaultName(String name, Collection&lt;String&gt; oneOrMoreAddressesEach)
.to(String name, InternetAddress address)
.to(InternetAddress address)
.to(String name, InternetAddress... oneOrMoreAddressesEach)
.toAddresses(String name, Collection&lt;InternetAddress&gt; oneOrMoreAddressesEach)
.toMultiple(InternetAddress... oneOrMoreAddressesEach)
.toMultipleAddresses(Collection&lt;InternetAddress&gt; oneOrMoreAddressesEach)
.toAddressesWithFixedName(String name, InternetAddress... oneOrMoreAddressesEach)
.toAddressesWithDefaultName(String name, InternetAddress... oneOrMoreAddressesEach)
.toAddressesWithFixedName(String name, Collection&lt;InternetAddress&gt; oneOrMoreAddressesEach)
.toAddressesWithDefaultName(String name, Collection&lt;InternetAddress&gt; oneOrMoreAddressesEach)
// CC
.cc(Recipient... recipients)
.cc(Collection&lt;Recipient&gt; recipients)
.cc(String name, String address)
.cc(String oneOrMoreAddresses)
.cc(String name, String... oneOrMoreAddressesEach)
.cc(String name, Collection&lt;String&gt; oneOrMoreAddressesEach)
.ccMultiple(String... oneOrMoreAddressesEach)
.ccAddresses(Collection&lt;String&gt; oneOrMoreAddressesEach)
.ccWithFixedName(String name, String... oneOrMoreAddressesEach)
.ccWithDefaultName(String name, String... oneOrMoreAddressesEach)
.ccWithFixedName(String name, Collection&lt;String&gt; oneOrMoreAddressesEach)
.ccWithDefaultName(String name, Collection&lt;String&gt; oneOrMoreAddressesEach)
.cc(String name, InternetAddress address)
.cc(InternetAddress address)
.cc(String name, InternetAddress... oneOrMoreAddressesEach)
.ccAddresses(String name, Collection&lt;InternetAddress&gt; oneOrMoreAddressesEach)
.ccMultiple(InternetAddress... oneOrMoreAddressesEach)
.ccMultipleAddresses(Collection&lt;InternetAddress&gt; oneOrMoreAddressesEach)
.ccAddressesWithFixedName(String name, InternetAddress... oneOrMoreAddressesEach)
.ccAddressesWithDefaultName(String name, InternetAddress... oneOrMoreAddressesEach)
.ccAddressesWithFixedName(String name, Collection&lt;InternetAddress&gt; oneOrMoreAddressesEach)
.ccAddressesWithDefaultName(String name, Collection&lt;InternetAddress&gt; oneOrMoreAddressesEach)
// BCC
.bcc(Recipient... recipients)
.bcc(Collection&lt;Recipient&gt; recipients)
.bcc(String name, String address)
.bcc(String oneOrMoreAddresses)
.bcc(String name, String... oneOrMoreAddressesEach)
.bcc(String name, Collection&lt;String&gt; oneOrMoreAddressesEach)
.bccMultiple(String... oneOrMoreAddressesEach)
.bccAddresses(Collection&lt;String&gt; oneOrMoreAddressesEach)
.bccWithFixedName(String name, String... oneOrMoreAddressesEach)
.bccWithDefaultName(String name, String... oneOrMoreAddressesEach)
.bccWithFixedName(String name, Collection&lt;String&gt; oneOrMoreAddressesEach)
.bccWithDefaultName(String name, Collection&lt;String&gt; oneOrMoreAddressesEach)
.bcc(String name, InternetAddress address)
.bcc(InternetAddress address)
.bcc(String name, InternetAddress... oneOrMoreAddressesEach)
.bccAddresses(String name, Collection&lt;InternetAddress&gt; oneOrMoreAddressesEach)
.bccMultiple(InternetAddress... oneOrMoreAddressesEach)
.bccMultipleAddresses(Collection&lt;InternetAddress&gt; oneOrMoreAddressesEach)
.bccAddressesWithFixedName(String name, InternetAddress... oneOrMoreAddressesEach)
.bccAddressesWithDefaultName(String name, InternetAddress... oneOrMoreAddressesEach)
.bccAddressesWithFixedName(String name, Collection&lt;InternetAddress&gt; oneOrMoreAddressesEach)
.bccAddressesWithDefaultName(String name, Collection&lt;InternetAddress&gt; oneOrMoreAddressesEach)
// GENERIC
.withRecipientsWithDefaultName(String defaultName, Collection&lt;String&gt; oneOrMoreAddressesEach, RecipientType recipientType)
.withRecipientsWithFixedName(String fixedName, Collection&lt;String&gt; oneOrMoreAddressesEach, RecipientType recipientType)
.withRecipientsWithDefaultName(String name, RecipientType recipientType, String... oneOrMoreAddressesEach)
.withRecipientsWithFixedName(String name, RecipientType recipientType, String... oneOrMoreAddressesEach)
.withRecipients(String name, boolean fixedName, RecipientType recipientType, String... oneOrMoreAddressesEach)
.withRecipients(String name, boolean fixedName, Collection&lt;String&gt; oneOrMoreAddressesEach, RecipientType recipientType)
.withAddressesWithDefaultName(String defaultName, Collection&lt;InternetAddress&gt; addresses, RecipientType recipientType)
.withAddressesWithFixedName(String fixedName, Collection&lt;InternetAddress&gt; addresses, RecipientType recipientType)
.withAddresses(String name, boolean fixedName, Collection&lt;InternetAddress&gt; addresses, RecipientType recipientType)
.withRecipients(Collection&lt;Recipient&gt; recipients)
.withRecipients(Recipient... recipients)
.withRecipients(Collection&lt;Recipient&gt; recipients, RecipientType fixedRecipientType)
.withRecipient(String singleAddress, RecipientType recipientType)
.withRecipient(String name, String singleAddress, RecipientType recipientType)
.withRecipient(Recipient recipient)</code></pre>
      </div>
    </div>
  </section>


  <a href="#authentication" id="authentication" class="section-link h2">&sect;</a>
  <h3>Authentication and OAUTH2 support</h3>
  <section>
	  <p class="wide">
		  You use one of the builder methods on <em>MailerBuilder</em> for defining the server properties like host, port, username and password.
	  </p>
	  <p class="wide">
		  Simple Java Mail supports plain SMTP (default, but not recommended), SMTPS (legacy SSL) or TLS (recommended). The last authentication option to join the family
		  is OAuth2 (by means of XOAUTH2 which comes built-in in Jakarta Mail, the underlying SMTP framework).
	  </p>
	  <p class="wide">
		  Then depending on the transport strategy that you choose, the password represents the SMTP server password or the OAuth2 token.
		  However, obtaining the OAuth2 token and refreshing tokens etc. is outside the scope of this library, which varies from platform to platform.
	  </p>

	  <div class="wide">
<pre><code>MailerBuilder
  .withSMTPServer("server host", 587, "username", yourPassword)
  .withTransportStrategy(TransportStrategy.SMTP_TLS)
  .buildMailer()
  .sendMail(email);
</code></pre>
		  <pre><code>MailerBuilder
  .withSMTPServer("server host", 587, "username", yourOAuth2Token)
  .withTransportStrategy(TransportStrategy.SMTP_OAUTH2)
  .buildMailer()
  .sendMail(email);
</code></pre>
	  </div>

	  <p class="wide">
		  See the security page for a more <a href="security.html#section-authentication-methods">in-depth explanation of transport strategies</a>.
	  </p>
  </section>


  <a href="#section-sending-asynchronously" id="section-sending-asynchronously" class="section-link h3">&sect;</a>
  <h3>Asynchronous parallel batch sending and clustering</h3>

  <section>
    <div class="view">
      <p>
        The default mode is to send emails synchronously, blocking execution until the email was processed completely and the STMP server sent a
        successful result.
      </p>
      <p>
        You can also send anyschronously in parallel or batches, or simply send in a fire-and-forget way. If an authenticated proxy is used, the <a
        href="#section-proxy">proxy bridging server</a> is kept alive until the last email has been sent.</p>
      <p>
        Depending on the SMTP server (and proxy server if used) this can greatly influence how fast emails are sent.
      </p>
    </div>

    <div class="side">
<pre><code>mailer.sendMail(email, /* async = */ true);
</code></pre>
      Or configure it when building the mailer:
      <pre><code>
Mailer mailer = mailerBuilder
  .(..)
  .async()
  .buildMailer();

mailer.sendMail(email);
</code></pre>
		<p>Refer to the <a href="configuration.html#section-programmatic-api-other">configuration section</a>
			on how to set the thread pool size default or how to configure the executor service (thread pool manager).</p>
    </div>
  </section>

  <section>
    <div>
      <p class="wide">
          <strong>Advanced batch processing</strong><br/>
        You can maximize performance by including the <strong><a href="modules.html#batch-module">batch-module</a></strong>,
        which allows you to pool the (Transport) connection over multiple sends, which generally saves 50% time for simpler emails). Going further, you can
        allow for multiple pooled connections to the same server and further still: even <strong>cluster multiple pools of connections</strong> to different servers!
      </p>
      <p class="wide">
        Refer to the <a href="configuration.html#section-batch-and-clustering">configuration section</a> for details.
      </p>
    </div>
  </section>

  <a href="#section-handling-async-result" id="section-handling-async-result" class="section-link h3">&sect;</a>
  <h3>Handling asynchronous mailing result</h3>

  <section>
    <div class="view">
      <p>
        To handle the successful or erroneous result of an async sent email, you can just register your handlers on the returned
		  <em><a href="https://www.baeldung.com/java-completablefuture" target="_blank">CompletableFuture</a></em>.
      </p>
      <p>
		  Also read this excellent primer on
		  <a href="https://mincong.io/2020/05/30/exception-handling-in-completable-future/" target="_blank">how to process exceptions with CompletableFuture</a>.
      </p>
      <p>
		  Note that non-async sending or testing connections return a CompletableFuture that is completed
		  <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html#completedFuture-U-" target="_blank">immediately</a>.
      </p>
    </div>

    <div class="side">
      <pre><code class="small">CompletableFuture&lt;Void&gt; f = mailer.sendMail(email, true);
// also mailer.testConnection(email, true)
// or mailerBuilder.async() and then just mailer.sendMail(email)

// one of the many ways you can handle the result:
mailer.testConnection(true)
	.whenComplete((result, ex) -> {
		if (ex != null) {
			System.err.printf("Execution failed %s", ex);
		} else {
			System.err.printf("Execution completed: %s", result);
		}
	});
</code></pre>
    </div>
  </section>


  <a href="#section-custom-session" id="section-custom-session" class="section-link h2">&sect;</a>
  <h2>Sending with your own Session instance</h2>

  <section>
    <div class="view">
      <p>
        If you prefer to use your own preconfigured <code class="inline language-java">Session</code> instance and still benefit from Simple Java Mail, you can!
      </p>
    </div>

    <div class="side">
<pre><code>Email email = ...
...

MailerBuilder
    .usingSession(yourSession)
    .buildMailer()
    .sendMail(email);
</code></pre>
    </div>
  </section>


  <a href="#section-content-transfer-encoding" id="section-content-transfer-encoding" class="section-link h2">&sect;</a>
  <h2>Changing the content encoding</h2>

  <section>
	  <div class="view">
		  <p>
			  By default content is encoded in the target MimeMessage or EML using <a href="https://docs.microsoft.com/en-us/previous-versions/office/developer/exchange-server-2010/aa579632(v=exchg.140)" target="_blank">quoted-printable</a>,
			  so the EML is nicely and safely readable. However, you can change it to many other encoders such as base64, which for example is useful if you want to add an extra layer of obfuscation.
		  </p>
		  <p>
			  The email header that governs this feature is <a href="https://www.w3.org/Protocols/rfc1341/5_Content-Transfer-Encoding.html" target="_blank">Content-Transfer-Encoding</a> and Simple Java Mail takes care of inserting this header in the right places, which varies depending on the
			  <a href="https://www.simplejavamail.org/rfc-compliant.html#section-explore-multipart">nescesary email structure</a>.
		  </p>
	  </div>

	  <div class="side">
		  <strong>quoted-printable</strong> (the default) results in the following EML subsection:
		  <pre><code class="language-text small">------=_Part_2_1226020905.1657715639009
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

We should meet up!
</code></pre>
		  <strong>base64</strong> on the other hand, produces the following:
		  <pre><code class="small">currentEmailBuilder.withContentTransferEncoding(ContentTransferEncoding.BASE_64)
</code></pre>
		  <pre><code class="language-text small">------=_Part_2_1226020905.1657715871203
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: base64

V2Ugc2hvdWxkIG1lZXQgdXAh
</code></pre>
	  </div>
  </section>

  <section>
	  <div class="view">
		  <p>
			  <strong>Encoding attachments</strong>
		  </p>
		  <p>
			  You can control encoding seperately for attachments, so your text files for examples can be encoded differently too.
		  </p>
	  </div>

	  <div class="side">
		  <pre><code class="language-java">.withAttachment("invitation.pdf", yourDataSource,
                "Invitation flyer", ContentTransferEncoding.BASE_64)

// or fix encoding by creating attachment objects directly
new AttachmentResource(..., ContentTransferEncoding.BINARY)
</code></pre>
	  </div>
  </section>

  <section>
	  <p class="wide">
		  <strong>Available encoders</strong>
	  </p>

	  <div class="wide">
<pre><code>currentEmailBuilder
    .withContentTransferEncoding(ContentTransferEncoding.QUOTED_PRINTABLE)
    .withContentTransferEncoding(ContentTransferEncoding.BASE_64)
    .withContentTransferEncoding(ContentTransferEncoding.BINARY)
    .withContentTransferEncoding(ContentTransferEncoding.B)
    .withContentTransferEncoding(ContentTransferEncoding.Q)
    .withContentTransferEncoding(ContentTransferEncoding.BIT7)
    .withContentTransferEncoding(ContentTransferEncoding.BIT8)
    .withContentTransferEncoding(ContentTransferEncoding.UU)
    .withContentTransferEncoding(ContentTransferEncoding.X_UU)
    .withContentTransferEncoding(ContentTransferEncoding.X_UUE)

	// or default back to quoted-printable
    .clearContentTransferEncoding()
</code></pre>
	  </div>
  </section>


  <a href="#section-custom-id" id="section-custom-id" class="section-link h2">&sect;</a>
  <h2>Setting a custom message ID on sent email</h2>

  <section>
    <div class="view">
      <p>Message id's are normally generated by the underlying Jakarta Mail framework, but you can provide your own if required.</p>
      <p>Just make sure your own id's conform to the <a href="https://datatracker.ietf.org/doc/html/rfc5322#section-3.6.4">rfc5322</a> msg-id format standard</p>
    </div>

    <div class="side">
<pre><code>currentEmailBuilder.fixingMessageId("<123@456>");
</code></pre>
    </div>
  </section>


  <a href="#section-custom-sentdate" id="section-custom-sentdate" class="section-link h2">&sect;</a>
  <h2>Setting a custom sent date on sent email</h2>

  <section>
    <div class="view">
      <p>Message sent date is normally filled with the current date, but you can provide your own date if required.</p>
    </div>

    <div class="side">
<pre><code class="small">currentEmailBuilder.fixingSentDate(new GregorianCalendar(2011, APRIL, 1, 3, 51).getTime());
</code></pre>
    </div>
  </section>


  <a href="#section-sent-id" id="section-sent-id" class="section-link h2">&sect;</a>
  <h2>Getting the generated email id after sending</h2>

  <section>
    <div class="view">
      <p>
        Sometimes you need the actual ID used in the MimeMessage that went out to the SMTP server.
        Luckily, it's very easy to retrieve it.
      </p>
    </div>

    <div class="side">
<pre><code>
mailer.sendMail(email); // id updated during sending!
email.getId(); // <1420232606.6.1509560747190@Cypher>
</code></pre>
    </div>
  </section>


  <a href="#section-ssl-tls" id="section-ssl-tls" class="section-link h2">&sect;</a>
  <h2>Sending with SSL and TLS</h2>

  <section>
    <div class="view">
      <p>
        Activating SSL or TLS is super easy. Just use the appropriate <code class="inline language-java">TransportStrategy</code> enum.
      </p>
    </div>

    <div class="side">
<pre><code class="small">Email email = ...;

MailerBuilder.withTransportStrategy(TransportStrategy.SMTP); // default if omitted
MailerBuilder.withTransportStrategy(TransportStrategy.SMTPS);
MailerBuilder.withTransportStrategy(TransportStrategy.SMTP_TLS);
MailerBuilder.withTransportStrategy(TransportStrategy.SMTP_OAUTH2);
</code></pre>

		Or with property default:
<pre><code class="language-properties small">simplejavamail.transportstrategy=SMTP
# or: SMTPS, SMTP_TLS, SMTP_OATH2
</code></pre>
    </div>
  </section>


  <section>
	  <div class="view">
		  <p>
			  <strong>Customizing SSL connections further</strong><br/>
			  For maximum control, you can provide your own SSLSocketFactory too:
		  </p>
	  </div>

	  <div class="side">
<pre><code>mailerBuilder
	.withCustomSSLFactoryClass(theClassName)
	.withCustomSSLFactoryInstance(theInstance) // takes precedence
	.buildMailer();
</code></pre>

		  Or with property default:
		  <pre><code class="language-properties small">simplejavamail.custom.sslfactory.class=you.project.YourSSLSocketFactory</code></pre>
	  </div>
  </section>


  <a href="#section-gmail" id="section-gmail" class="section-link h3">&sect;</a>
  <h3>SSL and TLS with Google mail</h3>

  <section>
    <div class="view">
      <p>
        Here's an example of SSL and TLS using gMail.
      </p>
      <p>
        If you have two-factor login turned on, you need to generate an <a href="https://security.google.com/settings/security/apppasswords">application
        specific
        password</a>
        from your Google account.
      </p>
    </div>

    <div class="side">
<pre><code>MailerBuilder
  .withSMTPServer("smtp.gmail.com", 25, "your user", "your password")
  .withTransportStrategy(TransportStrategy.SMTP_TLS)
  // or
  .withSMTPServer("smtp.gmail.com", 587, "your user", "your password")
  .withTransportStrategy(TransportStrategy.SMTP_TLS)
  // or
  .withSMTPServer("smtp.gmail.com", 465, "your user", "your password")
  .withTransportStrategy(TransportStrategy.SMTPS);
</code></pre>
    </div>
  </section>


  <a href="#section-attachments" id="section-attachments" class="section-link h2">&sect;</a>
  <h2>Adding attachments</h2>

  <section>
	  <div class="view">
		  <p>
			  You can add attachments very easily, but you'll have to provide the data yourself. Simple Java Mail accepts <code class="inline language-java">byte[]</code>
			  and <code class="inline language-java">DataSource</code> objects.
		  </p>
	  </div>

	  <div class="side">
<pre><code class="small">currentEmailBuilder
    .withAttachment("dresscode.txt", new ByteArrayDataSource("Black Tie Optional", "text/plain"))
    .withAttachment("location.txt", "On the moon!".getBytes(Charset.defaultCharset()), "text/plain")
    // ofcourse it can be anything: a pdf, doc, image, csv or anything else
    .withAttachment("invitation.pdf", new FileDataSource("invitation_v8.3.pdf"))
	// you can provide your own list of attachments as well
    .withAttachments(yourAttachmentResourceCollection))
</code></pre>
	  </div>
  </section>

  <section>
	  <div class="view">
		  <p>
			  If for some reason you need the <em>Content-Description</em> header set as well, you can provide a content description on any attachment.
		  </p>
	  </div>

	  <div class="side">
<pre><code class="language-java small">currentEmailBuilder.withAttachment(
	        "dresscode.txt",
	        new ByteArrayDataSource("Black Tie Optional", "text/plain"),
	        "The dresscode for the party")
</code></pre>
		  Which results in something like this:
		  <pre><code class="language-text">Content-Type: text/plain; filename="dresscode.txt"; name="dresscode.txt"
Content-Disposition: attachment; filename="dresscode.txt"
Content-ID: &lt;dresscode.txt&gt;
Content-Description: The dresscode for the party

Black Tie Optional
</code></pre>
	  </div>
  </section>

  <section>
	  <p class="wide">
		  You can further control how the attachment is encoded in the MimeMessage / EML until the data read back from the MimeMessage,
		  by <a href="#section-content-transfer-encoding"><strong>providing a content transfer encoding</strong></a> (resulting in a
		  Content-Transfer-Encoding header for the attachment).
	  </p>
  </section>


  <a href="#section-embedding" id="section-embedding" class="section-link h2">&sect;</a>
  <h2>Embedding images</h2>

	<section>
		<div class="view">
			<p>
				Embedding images dead simple with two options:
			</p>
			<ol class="indent">
				<li><strong>manual embedding:</strong> add <code class="inline language-text">cid:</code> placeholders in the HTML yourself</li>
				<li><strong>auto resolution:</strong> enable auto-resolving image sources to files, class path resources or URL's</li>
			</ol>
		</div>

		<div class="side">
			<p>
				Manual embedding:
			</p>
			<pre><code class="small">currentEmailBuilder.withEmbeddedImage("smiley", new FileDataSource("smiley.jpg"));
currentEmailBuilder.withEmbeddedImage("thumbsup", parseBase64Binary(base64String), "image/png");
// above example is included in the demo package in MailTestApp.java

// the corresponding HTML should contain the placeholders
&lt;p&gt;Let&#39;s go!&lt;/p&gt;&lt;img src=&#39;cid:thumbsup&#39;&gt;&lt;br/&gt;
&lt;p&gt;Smile!&lt;/p&gt;&lt;img src=&#39;cid:smiley&#39;&gt;
</code></pre>
		</div>
	</section>

	<section>
		<div class="view">
			<p>
				<strong>Auto resolution</strong> can be enabled for files, classpath resources and URL's and you can configure base dirs and optionally
				enforce that referenced resources should all be resolved successfully. Useful for when you allow end users to freely enter HTML.
			</p>
		</div>

		<div class="side">
			<p>
				Auto resolution:
			</p>
			<pre><code class="small">&lt;p&gt;Let&#39;s go!&lt;/p&gt;&lt;img src=&#39;smiley.jpg&#39;&gt;&lt;br/&gt;
&lt;p&gt;Smile!&lt;/p&gt;&lt;img src=&#39;https://www.myplace.com/smiley.png&#39;&gt;

// results in the following HTML when building the email:
&lt;p&gt;Let&#39;s go!&lt;/p&gt;&lt;img src=&#39;cid:etweffxdeu&#39;&gt;&lt;br/&gt;
&lt;p&gt;Smile!&lt;/p&gt;&lt;img src=&#39;cid:sienfddiew&#39;&gt;

email.getEmbeddedImages(); // now contains two data sources!
</code></pre>
			<p>
				To enable this:
			</p>
			<pre><code class="small">emailBuilder
	// enable auto resolution
	.withEmbeddedImageAutoResolutionForFiles(true) // default false
	.withEmbeddedImageAutoResolutionForClassPathResources(true) // default false
	.withEmbeddedImageAutoResolutionForURLs(true) // default false

	// support for base dirs
	.withEmbeddedImageBaseDir(RESOURCES_PATH + "/images")
	.withEmbeddedImageBaseUrl("https://www.simplejavamail.org/static/")
	.withEmbeddedImageBaseClassPath("/images")

	// allow resources outside of basedir (careful, potential security attack surface!)
	.allowingEmbeddedImageOutsideBaseDir(true) // default false
	.allowingEmbeddedImageOutsideBaseClassPath(true) // default false
	.allowingEmbeddedImageOutsideBaseUrl(true) // default false

	// fail if a resource couldn't be resolved
	.embeddedImageAutoResolutionMustBeSuccesful(true) // default false (lenient mode)
</code></pre>
			Also works with properties:
			<pre><code class="language-properties small">simplejavamail.embeddedimages.dynamicresolution.enable.dir=true
simplejavamail.embeddedimages.dynamicresolution.enable.url=true
simplejavamail.embeddedimages.dynamicresolution.enable.classpath=true
simplejavamail.embeddedimages.dynamicresolution.base.dir=...
simplejavamail.embeddedimages.dynamicresolution.base.url=https://www.simplejavamail.org/static/
simplejavamail.embeddedimages.dynamicresolution.base.classpath=/images
simplejavamail.embeddedimages.dynamicresolution.outside.base.dir=true
simplejavamail.embeddedimages.dynamicresolution.outside.base.classpath=true
simplejavamail.embeddedimages.dynamicresolution.outside.base.url=true
simplejavamail.embeddedimages.dynamicresolution.mustbesuccesful=true
</code></pre>
		</div>
	</section>


  <a href="#section-custom-headers" id="section-custom-headers" class="section-link h2">&sect;</a>
  <h2>Setting custom headers</h2>

  <section>
    <div class="view">
      <p>
        Sometimes you need extra headers in your email because your email server, recipient server or your email client needs it. Or perhaps you have
        a proxy or monitoring setup in between mail servers. Whatever the case, adding headers is easy.
      </p>
    </div>

    <div class="side">
<pre><code>currentEmailBuilder
    .withHeader("X-Priority", 2);
    .withHeader("X-MC-GoogleAnalyticsCampaign", "halloween_sale");
    .withHeader("X-MEETUP-RECIP-ID", "71415272");
    .withHeader("X-my-custom-header", "foo");
    // or
    .withHeaders(yourHeadersMap);
</code></pre>
    </div>
  </section>


  <a href="#section-custom-properties" id="section-custom-properties" class="section-link h2">&sect;</a>
  <h2>Setting custom properties on the internal Session</h2>

	<section>
		<div class="view">
			<p>
				In case you need to modify the internal Session object itself, because you need a tailored configuration that is supported by the underlying
				<code class="inline language-text">javax.mail</code>, that too is very easy.
			</p>
		</div>

		<div class="side">
<pre><code>currentMailerBuilder
    .withProperty("mail.smtp.timeout", 30 * 1000)
    .withProperty("mail.smtp.connectiontimeout", 10 * 1000)
    // or
    .withProperties(yourPropertiesObject)
    .withProperties(yourPropertiesMap)
</code></pre>
		</div>
	</section>

	<section>
		<div class="view">
			<p>
				You can also set some default properties to automatically be added.
			</p>
			<p>
				Every property prepended with <em>simplejavamail.extraproperties</em> will be loaded
				directly on the internal Session object.
			</p>
		</div>

		<div class="side">
<pre><code class="language-properties small">simplejavamail.extraproperties.my.extra.property=value
simplejavamail.extraproperties.mail.smtp.ssl.socketFactory.class=org.mypackage.MySSLSocketFactory
simplejavamail.extraproperties.mail.smtp.timeout=30000
</code></pre>
		</div>
	</section>


  <a href="#section-icalendar-vevent" id="section-icalendar-vevent" class="section-link h2">&sect;</a>
  <h2>Sending a Calendar event (iCalendar vEvent)</h2>

  <section>
    <div class="view">
      <p>
        You want to send a nice Calendar event (.ics) that a client such as Outlook processes nicely?
      </p>
      <p>Easy!</p>
      <p>
        Produce a Calendar event String (manually or by using a library such as <a href="https://github.com/ical4j/ical4j/wiki/Examples">ical4j</a>) and pass it to
        the <code class="inline language-java">EmailBuilder</code>.
      </p>
      <p>
        See the <a href="https://github.com/bbottema/simple-java-mail/blob/master/modules/simple-java-mail/src/test/java/demo/FullEmailDemoApp.java#L69">test demo app</a> included in the
        Simple Java Mail source for a working example.
      </p>
    </div>

    <div class="side">
<pre><code class="small">// Create a Calendar with something like ical4j
Calendar icsCalendar = new Calendar();
icsCalendar.getProperties().add(new ProdId("-//Events Calendar//iCal4j 1.0//EN"));
icsCalendar.getProperties().add(Version.VERSION_2_0);

(..) // add attendees, organizer, end/start date and whatever else you need

// Produce calendar string
ByteArrayOutputStream bOutStream = new ByteArrayOutputStream();
new CalendarOutputter().output(icsCalendar, bOutStream);
String yourICalEventString = bOutStream.toString("UTF-8")

// Let Simple Java Mail handle the rest
currentEmailBuilder
    .withCalendarText(CalendarMethod.REQUEST, yourICalEventString)
</code></pre>
    </div>
  </section>


  <a href="#section-session-access" id="section-session-access" class="section-link h2">&sect;</a>
  <h2>Direct access to the internal Session</h2>

  <section>
    <div class="view">
      <p>
        For emergencies, you can also get a hold of the internal Session instance itself. <strong>You should never need this however</strong> and if
        you do it means Simple Java Mail failed to simplify the configuration process for you. <strong>Please let us know how we can help alleviate
        this need</strong>.
      </p>
    </div>

    <div class="side">
<pre><code>Mailer mailer = ...;

Session session = mailer.getSession();
// do your thing with session
</code></pre>
    </div>
  </section>


  <a href="#section-return-receipt" id="section-return-receipt" class="section-link h2">&sect;</a>
  <h2>Configure delivery / read receipt</h2>

  <section>
    <div class="view">
      <p>
        For servers and clients that support it (mostly Outlook at offices), Simple Java Mail has built in support for
        <a href="https://www.chilkatsoft.com/p/p_313.asp">'delivery receipt' and 'read receipt'</a>, which is configured
        through the headers <code>Return-Receipt-To</code> and <code>Disposition-Notification-To</code> respectively.
      </p>
      <p>
        You can explicitly define the email address to return the receipts to or else Simple Java Mail will default
        to the <em>replyTo</em> address if available or else the <em>fromAddress</em>.
      </p>
      <p>
        If you simply enabled <code>Return-Receipt-To</code> or <code>Disposition-Notification-To</code> without providing
		an address, it will default to the first Reply-To recipient if provided or From recipient otherwise.
      </p>
    </div>

    <div class="side">
<pre><code class="small">currentEmailBuilder.
    .withDispositionNotificationTo();
    .withReturnReceiptTo();
    // or:
    .withDispositionNotificationTo(new Recipient("name", "address@domain.com"));
    .withReturnReceiptTo(new Recipient("name", "address@domain.com"));
</code></pre>
    </div>
  </section>


  <a href="#section-email-validation" id="section-email-validation" class="section-link h2">&sect;</a>
  <h2>Validating Email Addresses</h2>

  <section>
	  <div class="view">
		  <p>
			  Simple Java Mail can validate your email addresses. It's not just a simple regex check, but a complete and robust full validation against <a
				  href="https://tools.ietf.org/html/rfc2822">RFC-2822</a> and others. It does this by including <a href="https://github.com/RohanNagar/jmail">JMail</a> in the library.
		  </p>
		  <p>
			  Address validation is performed automatically when sending emails, but you can also directly perform validations.
		  </p>
		  <p>
			  See <a href="https://github.com/RohanNagar/jmail">JMail</a> for more examples and configurations.
		  </p>
	  </div>

	  <div class="side">
<pre><code>currentMailerBuilder
    .withEmailValidator(
		JMail.strictValidator()
    		.requireOnlyTopLevelDomains(TopLevelDomain.DOT_COM)
    		.withRule(email -> email.localPart().startsWith("allowed"))
	)
    // or
    .clearEmailValidator() // turn off validation
    .resetEmailValidator() // reset to default (strict)
</code></pre>
		  <pre><code>// you can also directly perform validations:
mailer.validate(email); // does all checks including address validation

// or just do the address validation
JMail.isValid("your_address@domain.com");

// or, fine-tuned to be stricter
JMail.strictValidator()
	.isValid("your_address@domain.com");
</code></pre>
	  </div>
  </section>

  <section>
	  <div class="view">
		  <p>
			  <strong>Note</strong>: any email address validation behaviour you have defined will be overridden
			  if you disable client-side validations completely (which also disables CRLF injection scanning).
		  </p>
	  </div>

	  <div class="side">
<pre><code>currentMailerBuilder
    .disablingAllClientValidation(true)
    // or
    .resetDisableAllClientValidations() // reset to default (false)
</code></pre>
	  </div>
  </section>


  <a href="#section-converting" id="section-converting" class="section-link h2">&sect;</a>
  <h2>Converting between, Email, MimeMessage, EML and Outlook .msg</h2>

  <section>
    <div class="view">
      <p>
        With Simple Java Mail you can easily convert between email types.
        This includes reading <a href="security.html#section-reading-smime">S/MIME protected emails</a> from file.
      </p>
      <p>
        For example, if you need a MimeMessage, you can convert <code class="inline language-java">Email</code> objects, EML data and even Outlook .msg files.
      </p>
      <p>
        If you already have a MimeMessage, you can convert it into an Email instance, complete with embedded images and attachments (or just the metadata), headers intact.
      </p>
      <p>
        You can even build a mass Outlook .msg to <a href="https://forensicswiki.xyz/page/EML">EML</a> converter if you like!
      </p>
      <br/>
      <p>
        To enable Outlook message parsing support, include the
        <strong><a href="modules.html#outlook-module">outlook-module</a></strong>.
        To enable S/MIME signed content and decryption support, include the
        <strong><a href="modules.html#smime-module">smime-module</a></strong>
      </p>
    </div>

    <div class="side">
<pre><code class="small">/*
 * Most conversion methods support an optional Pkcs12Config config for handling S/MIME
 */

// from Email
String eml =              EmailConverter.emailToEML(yourEmail);
MimeMessage mimeMessage = EmailConverter.emailToMimeMessage(yourEmail);
MimeMessage mimeMessage = EmailConverter.emailToMimeMessage(yourEmail, yourSession);

// from MimeMessage
Email email =             EmailConverter.mimeMessageToEmail(yourMimeMessage);
String eml =              EmailConverter.mimeMessageToEML(yourMimeMessage);

// from EML
Email email =             EmailConverter.emlToEmail(emlDataString);
MimeMessage mimeMessage = EmailConverter.emlToMimeMessage(emlDataString);
MimeMessage mimeMessage = EmailConverter.emlToMimeMessage(emlDataString, yourSession);

// from Outlook .msg
Email email =             EmailConverter.outlookMsgToEmail(readToString("yourMessage.msg"));
Email email =             EmailConverter.outlookMsgToEmail(new File("yourMessage.msg"));
Email email =             EmailConverter.outlookMsgToEmail(getInputStream("yourMessage.msg"));
String eml =              EmailConverter.outlookMsgToEML(readToString("yourMessage.msg"));
String eml =              EmailConverter.outlookMsgToEML(new File("yourMessage.msg"));
String eml =              EmailConverter.outlookMsgToEML(getInputStream("yourMessage.msg"));
MimeMessage mimeMessage = EmailConverter.outlookMsgToMimeMessage(readToString("yourMessage.msg"));
MimeMessage mimeMessage = EmailConverter.outlookMsgToMimeMessage(new File("yourMessage.msg"));
MimeMessage mimeMessage = EmailConverter.outlookMsgToMimeMessage(getInputStream("yourMessage.msg"));

Pkcs12Config myKeyInfo = Pkcs12Config.builder()
    .pkcs12Store("my_smime_keystore.pkcs12")
    .storePassword("my_store_password")
    .keyAlias("my_key_alias")
    .keyPassword("my_key_password")
    .build();

Email decryptedEmail =    EmailConverter.emlToEmail(emlDataString, myKeyInfo);
Email decryptedEmail =    EmailConverter.mimeMessageToEmail(yourMimeMessage, myKeyInfo);
Email decryptedEmail =    EmailConverter.mimeMessageToEmail(yourMimeMessage, myKeyInfo, /*fetchAttachments*/ false);
emailBuilder   	     =    EmailConverter.mimeMessageToEmailBuilder(yourMimeMessage, /*Pkcs12Config*/ null, /*fetchAttachments*/ true);
</code></pre>
    </div>
  </section>


  <a href="#section-bouncing-emails" id="section-bouncing-emails" class="section-link h2">&sect;</a>
  <h2>Setting custom recipient for bouncing emails</h2>

  <section>
    <div class="view">
      <p>
        For bouncing emails, you can provide a hint to the SMTP server to which bouncing emails should be returned.
        This is also known as the Return-Path or Envelope FROM and is set on the Session instance with the property
        <code class="inline language-properties">mail.smtp.from</code>.
      </p>
      <p>
        Simple Java Mail offers a convenience method to set this property.
      </p>
    </div>

    <div class="side">
<pre><code>// in similar fashion to setting replyTo address:
currentEmailBuilder
    .withBounceTo(aRecipientInstance) // or
    .withBounceTo("Bob", "bob.techdesk@candyshop.com")
    // or using one of the many alternative methods...
</code></pre>
    </div>
  </section>


  <a href="#section-reply-forward" id="section-reply-forward" class="section-link h2">&sect;</a>
  <h2>Replying to and forwarding emails</h2>

  <section>
    <div class="view">
      <p>
        If you have an email you want to reply to or wish to forward, the <code class="inline language-java">EmailBuilder</code>
        has you covered.
      </p>
      <br />
      <div>
        <p>
          <strong>Note:</strong> due to the nature of the underlying Jakarta Mail framework (also see
          <a href="https://jakartaee.github.io/mail-api/FAQ#reply" target="_blank">reply</a> /
          <a href="https://jakartaee.github.io/mail-api/FAQ#forward" target="_blank">forward</a>):
        </p>
        <ul class="indent">
          <li>In case of replying, the original email is quoted in the body of the reply itself.</li>
          <li>In case of forwarding, the original email is included as a separate body inside the forward.</li>
        </ul>
      </div>
    </div>

    <div class="side">
      <p>Replying to an email:</p>
      <pre><code>EmailBuilder
    .replyingTo(receivedEmail) // Email or MimeMessage
    .from("dummy@domain.com")
    .prependText("Reply body. Original email included below")
    .buildEmail();
</code></pre>
      <p>Forwarding an email:</p>
      <pre><code>EmailBuilder
    .forwarding(receivedEmail) // Email or MimeMessage
    .from("dummy@domain.com")
    .text("Hello? This is Forward. See below email:")
    .buildEmail();
</code></pre>
    </div>
  </section>


  <a href="#section-proxy" id="section-proxy" class="section-link h2">&sect;</a>
  <h2>Send using a proxy</h2>

  <section>
    <div>
      <p class="wide">
        Simple Java Mail supports sending emails through a proxy. It is also the only java mailing framework in the world that supports sending emails
        through <strong>authenticated</strong> proxies. The reason for this is that the underlying native
        <a href="https://jakartaee.github.io/mail-api/" target="_blank">Jakarta Mail framework</a> supports anonymous SOCKS5 proxies, but
        <a href="https://jakartaee.github.io/mail-api/FAQ.html#proxy" target="_blank">not authenticated proxies</a>.
      </p>
      <p class="wide">
        To make this work with authentication, Simple Java Mail uses a trick: it sets up a temporary anonymous proxy server for Javax Mail to connect
        to and then the bridge relays the connection to the target proxy performing the authentication outside of Javax Mail.
      </p>
      <p class="wide">
        This temporary server is referred to as the <strong>Proxy Bridging Server</strong>.
      </p>
    </div>

    <div>
<pre><code>// anonymous proxy
currentMailerBuilder.withProxy("proxy.host.com", 1080)

// authenticated proxy
currentMailerBuilder.withProxy("proxy.host.com", 1080, "proxy username", "proxy password");
</code></pre>
      <p>Refer to the <a href="configuration.html#section-other-settings">configuration section</a>
        on how to set proxy server defaults and the port on which the proxy bridge runs.</p>
    </div>
  </section>


  <a href="#section-connection-test" id="section-connection-test" class="section-link h2">&sect;</a>
  <h2>Testing a server connection</h2>

  <section>
    <div class="view">
      <p>
        If you just want to do a connection test using your current configuration, including transport strategy and (authenticated)
        proxy, Simple Java Mail got you covered.
      </p>
      <p>
        The connection test can also be done asynchronously and the result can be handled asynchronously as well. Take a look at
        <a href="#section-handling-async-result">Handling asynchronous mailing result</a>.
      </p>
    </div>

    <div class="side">
<pre><code>// configure your mailer
Mailer mailer = ...;

// perform connection test
mailer.testConnection(/* async? */); // no error means success
</code></pre>
    </div>
  </section>


	<a href="#section-serializing-emails" id="section-serializing-emails" class="section-link h2">&sect;</a>
	<h2>Serializing Email objects</h2>

	<section>
			<p class="wide">
				Simple Java Mail supports native Java serialization for Email objects with the following caveats:
			</p>
      <ul class="indent wide">
        <li>AttachmentResource.dataSource of type DataSource is transient</li>
        <li>Email.emailToForward of type MimeMessage is transient</li>
        <li>Email.dkimPrivateKeyInputStream of type InputStream is transient</li>
        <li>Email.smimeSigningConfig of type SmimeSigningConfig is transient</li>
      </ul>
	</section>


	<a href="#section-custom-mailer" id="section-custom-mailer" class="section-link h2">&sect;</a>
	<h2>Plug your own sending logic</h2>

	<section>
        <p class="wide">
          You want to benefit from Simple Java Mail's powerful features, but want to replace the actual
            server testing and email sending with your own? <br/>Simple Java Mail's got your back. Just
			Define your own <em>CustomMailer</em> and plug it in.
        </p>

    <hr/>
        <div class="wide">
          <p>Send mail using MailGun REST API:</p>
		    <pre><code>Mailer mailGunMailer = MailerBuilder
      .withCustomMailer(new MailGunMailer())
      .(..)
      .buildMailer();
</code></pre>
		    <pre><code>public class MailGunMailer implements CustomMailer {

	@Override
	public void testConnection(OperationalConfig operationalConfig, Session session) {
		// call MailGun rest service to test the provided config
	}

	@Override
	public void sendMessage(OperationalConfig operationalConfig, Session session, Email email, MimeMessage message) {
		// call MailGun rest service to send the email!
	}
}
  </code></pre>
      </div>
	</section>


	<a href="#section-maximum-emailsize" id="section-maximum-emailsize" class="section-link h2">&sect;</a>
	<h2>Limit the maximum email size</h2>

	<section>
        <p class="wide">
          Do you know your server's maximum allowed email size? Then it might be helpful to have Simple Java Mail reject
			emails that exceed this before trying to send them.
        </p>
    <hr/>
		<p class="wide">
			The following throws an EmailTooBig exception as the <em>cause</em> in a parent MailerException instance
		</p>
        <div class="wide">
		    <pre><code>Mailer mailer = MailerBuilder
      .(..)
      .withMaximumEmailSize(4) // 4 bytes, that's not much
      .buildMailer();

try {
	mailer.sendMail(emailBiggerThan4Bytes)
} catch(Exception e) {
	// cause: EmailTooBigException
	// msg: "Email size of 277 bytes exceeds maximum allowed size of 4 bytes"
	e.getCause().printStrackTrace();
}
</code></pre>
      </div>
	</section>
    {{/inline}}

{{/layouts/base}}
